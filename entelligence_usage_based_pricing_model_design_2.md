# Usage-Based Pricing Model Design - entelligenceAI/backend
*Generated by Entelligence Doc Agent*

---

### 1. Executive Summary

Implementing a usage-based pricing model through a credits system for our platform. The goal is to seamlessly weave this into our existing codebase without missing a beat. We want to make sure that users get a fair shot at our services while ensuring our billing and credit systems are sleek and intuitive. This document walks you through the journey of implementing the credits system right down to the last code snippet.

---

### 2. Current State Deep Dive

Before we dive into building, let’s see what we’re working with:

- **Programming Languages:** We're heavily relying on Python, with Django holding the fort for our backend framework. We also use FastAPI for certain microservices. Our `billing` directory, predominantly using Django, interacts with Stripe via APIs such as those found in `billing/stripe_api.py`.

- **Database Setup:** We’re running on MySQL, integrated with Django ORM for schema management. Key models regarding payments and users reside in `billing/models.py` and `user/models.py`.

- **Payment Integration:** Stripe is our current go-to for billing. It’s implemented in several parts of our codebase, notably in `billing/stripe_api.py`.

- **Major Classes and Functions:** The `StripeCustomer` class in `billing/models.py` manages Stripe customer IDs, and `PaymentEvent` tracks payment events.

- **Authentication:** OAuth and JWT handle session management, found in modules like `slackbot/views.py`.

---

### 3. Proposed Technical Design

Here’s how we'll build the credits system:

#### Credits System Architecture

- **User Credits Initialization:**
  - On signup or subscription, allocate credits to the user. Extend `UserModel` in `user/models.py` to include a `credits` field:  

  ```python
  class UserModel(models.Model):
      credits = models.IntegerField(default=initial_credit_value) # initial_credit_value defined in settings
  ```

- **Credits Consumption:**
  - Disconnects from the existing tracking system that relies on Stripe payments. Reference `billing/views.py` to integrate credit deductions when users perform actions.

- **Real-Time Tracking:**
  - Use a middleware approach similar to our existing `LoggingMiddleware` in `root/djangoMiddleware.py` to intercept actions and adjust credits.

#### Usage Tracking & Metering

- **Enhance `metrics/models.py`** to accommodate credit consumption linked with usage tracking. Additional utility functions can be added in `metrics/utils.py` for calculating consumption rates. Recommended schema updates:

  ```python
  class UsageMetrics(models.Model):
      user = models.ForeignKey(UserModel, on_delete=models.CASCADE)
      credits_spent = models.IntegerField()
      action_type = models.CharField(max_length=255)
      timestamp = models.DateTimeField(auto_now_add=True)
  ```

#### Pricing Tiers & Models

- Explore a modular setup to support multiple tiers by extending functions like `get_plan_details_ctrl` in `billing/controller.py` to return credit-based plan details for users.

#### Billing & Payment Integration

- We will continue leveraging Stripe for payments. Introduce new logic in `billing/views.py` to handle "top-up" transactions and translate them into credit additions.

```python
def purchase_credits(request):
    # Extract credit details from request and interact with Stripe API
    # Top-up approach as an alternative plan in 'billing/controller.py'
```

---

### 4. Implementation Tickets

1. **Add Credits Field to UserModel:**
   - **Objective:** Add a `credits` field to `UserModel` in `user/models.py`.
   - **Files:** `user/models.py`, `migrations/`
   - **Integration Points:** Initialize with default credits upon account creation.

2. **Middleware for Credits Consumption:**
   - **Objective:** Develop middleware to handle real-time credit tracking.
   - **Files:** `root/djangoMiddleware.py`
   - **Integration Points:** Intercept user actions to adjust credits accordingly.

3. **Credits Transaction APIs:**
   - **Objective:** Build API endpoints for credit purchase and usage logging.
   - **Files:** `billing/views.py`, `billing/controller.py`
   - **Integration Points:** Use Stripe API for purchasing processes.

4. **Update Metrics for Usage Tracking:**
   - **Objective:** Adjust `metrics/models.py` to track and record credits usage.
   - **Files:** `metrics/models.py`, `metrics/controller.py`
   - **Integration Points:** Create new database entries on usage events.

---

### 5. Code Examples

- **Middleware Snippet for Credit Management:**

```python
class CreditsMiddleware(MiddlewareMixin):
    def process_request(self, request):
        user_id = request.user.id
        # Assuming action generates a consumption event
        user = UserModel.objects.get(id=user_id)
        user.credits -= consumption_rate  # Define consumption_rate logic
        user.save()
```

- **API Endpoint for Credit Purchase:**

```python
@api_view(['POST'])
def purchase_credits_view(request):
    user = request.user
    # Process purchase with Stripe and modify user's credits
    # Handle return of success or error response
```

---

### 6. Migration & Deployment

- **Phase 1:** Add migration for user credits.
- **Phase 2:** Deploy middleware for credit usage tracking.
- **Phase 3:** API enhancements for credit purchase integration.
- **Phase 4:** Rollout and monitor metrics adjustments.

---

### 7. Edge Cases & Risks

- **Concurrency Issues:** Ensure atomic operations on credits deduction to prevent race conditions.
- **Data Integrity:** Validate API interactions with Stripe to handle failures gracefully.
- **Historical Data:** Ensure historical transactions are logged to avoid discrepancies.

In conclusion, by adhering to this plan, we aim to create a robust credits-based system intertwined with our current backend infrastructure. This will enhance control over how we scale pricing and billing in user-centric manners.

---