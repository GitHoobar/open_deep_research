# Deep Research Analysis
*Generated by Open Deep Research*

**Repository:** https://github.com/Entelligence-AI/backend
**Query:** Design a usage-based pricing model for our code review and doc generation platform.
**Generated:** 2025-07-24 01:16:57
**Model:** gpt-4.1-mini

---

# Design Document: Usage-Based Pricing Model for Code Review & Documentation Platform

---
### Date: Thu Jul 24, 2025  
### Audience: Engineering Team (Backend, API, Admin UI, DevOps)  
### Goal: Implement metered usage billing tied to user activities, flexible plans, and payment integration based on analysis of existing codebase

---

## 1. Executive Summary

Hey team, we’re adding a usage-based pricing layer to our platform that better aligns customer payment with actual usage. We want to track key user activities like lines reviewed, docs generated, and API calls, then bill users with flexible plans featuring quotas, overages, and free tiers. Going beyond just tracking, we'll integrate with Stripe/PayPal for payments, generate invoices/receipts, push notifications for usage/billing events, and build an admin dashboard for plan and billing management.

This document breaks down how we tie this cleanly into our existing codebase — reusing the usage event model and middleware we have, enhancing billing models, adding payment processing integrations, plus backend APIs and admin UI. We'll also cover everything from DB schema to PCI compliance, monitoring, error handling, and deployment, so the rollout is smooth and scalable.

---

## 2. Current State Deep Dive

### 2.1 Usage Metering - `usage/models.py`, `core/middleware.py`, `api/views.py`

- We already log `UsageEvent` records that capture granular user actions (`user_id`, `timestamp`, `action_type`, metadata).
- Middleware in `core/middleware.py` intercepts requests, logging relevant `UsageEvent`s for API usage.
- Critical API views (in `api/views.py`) are decorated/extended for incrementing usage (code review, doc gen).

### 2.2 Pricing Plans and Subscription - `billing/models.py`

- We have `Plan` models defining attributes like quotas, pricing, enabled features.
- `UserSubscription` links users/orgs to a plan, though current feature set is limited.
- Lacks support for nuanced credit balances, free tiers, or overage logic.

### 2.3 Billing External Integrations - `billing/integrations/stripe.py`, `billing/integrations/paypal.py`

- Standard Stripe and PayPal SDK-based integration modules exist with basic subscription/payment support.
- Webhook endpoints in `billing/webhooks.py` listen for payment events but need enrichment.
- No standardized invoice generation or reconciliation implemented.

### 2.4 Notification System - `notifications/models.py`, `notifications/services.py`

- Notifications exist as a database-backed model with delivery via email/in-app.
- Currently used for basic alerts; no connection yet to usage thresholds or billing events.

### 2.5 Admin and Analytics - `admin/dashboard.py`

- Admin UI exists with rudimentary plan management & metrics.
- Needs richer analytics (usage trends, revenue, churn) and billing user history.

### 2.6 Database & Logging

- Models are well-indexed and suitable for aggregation, but billing/audit capabilities are minimal.
- Audit trail models are present (`audit/models.py`) but don’t yet cover billing actions.

---

## 3. Proposed Technical Design

### 3.1 Usage Metering Enhancements

- Continue centralized logging in `usage/models.py` with `UsageEvent`: extend `action_type` enum (e.g., `code_review`, `doc_generation`, `api_call`).
- Add `usage/services.py`: atomic functions to meter and check available credits before action proceeds.
- Batch aggregation task (`billing/tasks.py`) to roll up daily per-user aggregates for billing accuracy and analytics.
- Hook `UsageMeterMiddleware` in `core/middleware.py` to call these services consistently.

---

### 3.2 Pricing Plans, Quotas, and Credit-Based Billing

- Expand `Plan` model in `billing/models.py` with fields:
  - `included_quota` (JSON per action type, e.g., 10,000 lines reviewed/month)
  - `overage_rates` (cost per unit beyond quota)
  - `periodic_price` (monthly/annual)
  - `is_free_tier` boolean flag
  - Metadata for enterprise plan flags (e.g., custom features)

- `UserSubscription` is extended with a linked `CreditBalance` model to:
  - Track per-action-type credit availability
  - Auto top-up credits on billing cycle renewals
  - Trigger notifications at usage thresholds

- Define `billing/services.py` to:
  - Deduct credits on usage events (atomic DB transaction)
  - Calculate and add overage charges post quota
  - Provide free-tier enforcement (e.g., block or warn on limit exceeded)

---

### 3.3 Payment Processor Integration & Billing Workflows

- `billing/integrations/stripe.py` and `paypal.py` will be extended to:
  - Create/update subscriptions reflecting usage tiers and quotas
  - Handle payment retries, failed payment events
  - Generate and store external payment/invoice IDs in `Invoice` model

- `billing/webhooks.py` will have idempotent handlers for:
  - Payment succeeded/failed
  - Subscription updated/canceled
  - Invoice generated/paid

- On payment success, trigger PDF generation with `billing/documents.py` and email via notification service.

---

### 3.4 Invoice & Receipt Generation

- Use `billing/documents.py` leveraging WeasyPrint/ReportLab to:
  - Create PDFs from templates containing plan details, usage summary, and charges
  - Store the files securely with metadata in `Invoice` model (`file_path`, `status`)
  - Generate signed URLs or secure attachments for downloading

- Automate invoice dispatch upon payment event via `notifications/services.py`.

---

### 3.5 Notifications

- Implement event-driven notifications:
  - 80% usage threshold warnings, credit low alerts, failed billing events, invoice issued notices.
- Add notification types in `notifications/models.py` with tracking for read/unread.
- Admin UI and user settings to manage notifications.

---

### 3.6 Admin Dashboard & Analytics Enhancements

- Extend `admin/dashboard.py` or create React admin pages to:
  - CRUD Plans and adjust quotas/overage prices.
  - Display subscription summaries, active users by plan.
  - Show usage trends, revenue, overdue payments, churn rates.
  - Drill into user billing history and invoices.

---

### 3.7 API Layer Additions

- Add `/api/usage` endpoints in `api/views.py`:
  - `GET` usage summaries 
  - `POST` usage event recording (for external integrations)
- Extend `/api/billing` for:
  - Subscription creation/modification
  - Invoice retrieval
  - Credit balance queries
- Secure APIs with JWT or OAuth2 tokens in `api/permissions.py`.

---

### 3.8 Database Schema & Storage Strategy

| Model | Key columns/functionality | Notes |
|-------|---------------------------|-------|
| `UsageEvent` (`usage/models.py`) | `user_id`, `timestamp`, `action_type`, `metadata` | core event source for usage |
| `Plan` (`billing/models.py`) | `name`, `included_quota` (JSON), `overage_rate`, `periodic_price` | pricing tiers |
| `UserSubscription` (`billing/models.py`) | FK to user, plan, billing cycle info | links user to usage plan |
| `CreditBalance` (`billing/models.py`) | per-user credit counts per action | model to atomically deductible credits |
| `Invoice` (`billing/models.py`) | invoice number, user, status, amount, file_url | invoice metadata |
| `Notification` (`notifications/models.py`) | user, type, status, read_at | notification lifecycle |
| `AuditTrail` (`audit/models.py`) | user, action, timestamp, data | capture billing-related sensitive events |

Indexes on `user_id`, `timestamp` fields to optimize aggregation.

---

### 3.9 Security & Compliance

- Strictly no raw card data stored — handled via Stripe/PayPal SDKs only.
- All billing API endpoints secured (OAuth2/JWT) with role-based access control.
- TLS enforced and personal identifiable info encrypted at rest.
- Audit trail captures all billing changes and invoice accesses.
- Payment webhooks verified by signature (Stripe/PayPal) for authenticity.

---

### 3.10 Monitoring, Audit & Error Handling

- Structured JSON logging configured in `logging_config.py` for:
  - Usage meter events  
  - Billing transactions  
  - Payment webhook processing  

- `AuditTrail` in `audit/models.py` records critical payment and plan changes.

- Retry logic in `billing/tasks.py` for failed payment attempts with exponential backoff.

- Immediate user notifications on persistent failures plus admin alerts.

---

### 3.11 Migration & Deployment Strategy

- Non-destructive migrations adding `CreditBalance`, `Invoice`, `Notification` tables + indexes.

- Backfill script (`scripts/billing_backfill.py`) to populate usage aggregates for billing start.

- Feature flags around billing enabling (`billing/feature_flags.py`) for progressive rollout.

- Deploy first to staging, perform integration tests of webhooks, API, notifications.

- Gradual rollout with usage monitoring and fallback switches.

---

## 4. Implementation Tickets

**Ticket 1: Define and migrate usage event model enhancements**  
- File: `usage/models.py`  
- Add usage action types, indexes for efficient querying  
- Migration script to update/extend schema

**Ticket 2: Instrument middleware and API views for usage metering**  
- Files: `core/middleware.py`, `api/views.py`, `usage/services.py`  
- Implement atomic credit deductions on usage  
- Enforce limits for free tier users

**Ticket 3: Expand `Plan` and `UserSubscription` models**  
- File: `billing/models.py`  
- Add `included_quota`, `overage_rate`, `CreditBalance`  
- Implement periodic credit top-up logic

**Ticket 4: Integrate Stripe and PayPal payment processing**  
- Files: `billing/integrations/stripe.py`, `paypal.py`, `billing/webhooks.py`  
- Implement subscription lifecycle APIs  
- Idempotent webhook handlers for payment/invoice events

**Ticket 5: Build invoice generation & emailing**  
- Files: `billing/documents.py`, `billing/models.py`, `notifications/services.py`  
- PDF generation with usage/billing details  
- Secure storage & email dispatch

**Ticket 6: Implement notification system for usage and billing alerts**  
- Files: `notifications/models.py`, `notifications/services.py`, integration hooks in billing services  
- Enable user and admin notification handling

**Ticket 7: Create admin UI for plan & billing management and analytics**  
- Files: `admin/dashboard.py`, frontend React components (as needed)  
- CRUD for plans, user subscription view, usage & revenue reports

**Ticket 8: Add public API endpoints for usage and billing data**  
- Files: `api/views.py`, `api/serializers.py`, auth middlewares  
- Secure RESTful endpoints for usage, billing, subscription data

**Ticket 9: Implement audit trails and structured logging**  
- Files: `audit/models.py`, `logging_config.py`, billing and usage logic hooks  
- Capture all billing-critical operations

**Ticket 10: Error handling and payment retry workflows**  
- Files: `billing/tasks.py`, `billing/workflows.py`  
- Automated retry for failed payments with escalation notifications

**Ticket 11: Create migration and backfill scripts with feature flags**  
- Files: `scripts/billing_backfill.py`, `billing/feature_flags.py`  
- Rollout coordination and data syncing

---

## 5. Code Examples

### Example: Atomic Credit Deduction in `usage/services.py`

```python
from django.db import transaction
from billing.models import CreditBalance, UserSubscription
from usage.models import UsageEvent

def record_usage_and_deduct_credit(user, action_type, usage_amount=1, metadata=None):
    subscription = UserSubscription.objects.select_for_update().get(user=user)
    credit = CreditBalance.objects.select_for_update().get(subscription=subscription, action_type=action_type)

    with transaction.atomic():
        if credit.amount < usage_amount:
            # Handle free tier or block usage
            raise UsageLimitExceeded(f"Not enough credits for {action_type}")

        # Deduct credits
        credit.amount -= usage_amount
        credit.save()

        # Save usage event
        UsageEvent.objects.create(
            user=user,
            action_type=action_type,
            metadata=metadata or {},
        )
    return True
```

---

### Example: Stripe Webhook Handling in `billing/webhooks.py`

```python
import stripe
from django.views.decorators.csrf import csrf_exempt
from django.http import HttpResponse, JsonResponse
from billing.models import Invoice, UserSubscription
from django.conf import settings

@csrf_exempt
def stripe_webhook(request):
    payload = request.body
    sig_header = request.META.get('HTTP_STRIPE_SIGNATURE')

    try:
        event = stripe.Webhook.construct_event(payload, sig_header, settings.STRIPE_WEBHOOK_SECRET)
    except (ValueError, stripe.error.SignatureVerificationError):
        return HttpResponse(status=400)

    if event.type == 'invoice.payment_succeeded':
        handle_payment_succeeded(event.data.object)
    elif event.type == 'invoice.payment_failed':
        handle_payment_failed(event.data.object)
    # idempotent processing here

    return HttpResponse(status=200)

def handle_payment_succeeded(invoice_data):
    invoice, created = Invoice.objects.get_or_create(
        external_id=invoice_data['id'],
        defaults={
            'user': get_user_from_customer(invoice_data['customer']),
            'amount': invoice_data['amount_paid'] / 100,
            'status': 'paid',
            'date': timestamp_to_datetime(invoice_data['created']),
        }
    )
    # Generate PDF and send email
    generate_and_send_invoice(invoice)
```

---

### Example: Notification Trigger in `billing/services.py`

```python
from notifications.services import send_notification

def notify_if_usage_threshold(user, action_type, used, quota):
    percent_used = (used / quota) * 100
    if percent_used >= 80:
        send_notification(
            user=user,
            notification_type='usage_threshold',
            message=f"You have used {percent_used:.0f}% of your {action_type} quota."
        )
```

---

## 6. Migration & Deployment

- Begin with DB migrations to add:

  - `CreditBalance` table linked to `UserSubscription`
  - `Invoice` table with metadata fields
  - Additional columns on `Plan` for quota and overage
  
- Run data backfill:

  - Batch script reads historical `UsageEvent`s to populate initial credit deductions and aggregates
  
- Wrap billing logic behind feature flag (`billing/feature_flags.py`) initially disabled.

- Deploy to staging, verify:

  - Usage events record credits correctly
  - Payments flow with Stripe and PayPal Webhooks
  - Invoice generation produces valid PDFs and notifications fire

- Gradually enable feature flag in production subset of users.

- Monitor logs and audit for discrepancies.

---

## 7. Edge Cases & Risks

### 7.1 Race Conditions on Credit Deduction  
- Use DB row-level locks (`select_for_update`) in `usage/services.py` to prevent overspending credits in concurrent requests.

### 7.2 Idempotent Webhook Processing  
- Webhooks from Stripe/PayPal may arrive multiple times. Use unique external invoice/payment IDs to avoid double processing.

### 7.3 Free Tier Abuse & Overages  
- Detect abuse patterns (e.g., excessive API calls) through analytics and enforce throttle or manual intervention as needed.

### 7.4 Payment Failures  
- Implement automatic retries with exponential backoff (`billing/tasks.py`).
- Notify both user and admins promptly on persistent failure to avoid revenue loss.

### 7.5 Data Privacy & PCI Compliance  
- Never log or store raw card data.
- Sanitize logs and notifications.
- Validate and encrypt PII in invoices.

### 7.6 Migration Risks  
- Backfill usage data could be heavy -> batch in smaller chunks.
- Feature flag rollback plan must be ready in case of critical bugs in billing flow.

---

# Wrap-up

This design breaks down our pricing system into manageable, well-scoped enhancements tightly integrated with code we already have, aimed at a smooth rollout with robust security, scalability, and rich functionality. Next step, let’s pick up Ticket 1 and get our migration rolling!

---  
*Ping me if any spot needs clearer deep dive or if you want a walkthrough of integration patterns.*