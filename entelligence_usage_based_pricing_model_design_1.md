# Usage-Based Pricing Model Design - entelligenceAI/backend
*Generated by Design Doc Agent*

## Overview
This document outlines the design for implementing a comprehensive usage-based pricing model with credits system for code review and documentation generation services.

---

# Usage-Based Pricing Model with Credits System Design Document

## Executive Summary

Hey team! We're diving into something pretty exciting today: a usage-based pricing model with a credits system for our code review and documentation generation platform. This will give us the flexibility to cater to different user needs and help us scale. In simple terms, users will have credits, and they use these credits for operations on our platform. The whole idea is to make our pricing flexible and dynamic, improving our competitiveness in the market. Let's break down exactly how we're going to build this.

## Current State Deep Dive

Before tackling this, let's look at where we currently stand code-wise. 

### Key Components:

1. **User Management**: 
   - **File**: `user/models.py`
     - `UserModel` is our go-to class for managing everything user-related, including email, UUID, and details about subscription status.
   
2. **Billing System**:
   - **File**: `billing/models.py`
     - `StripeCustomer` and `PaymentEvent` are foundational. These are our building blocks for understanding who our customers are and keeping tabs on their transactions.

3. **Metrics**:
   - **File**: `metrics/models.py`
     - `AggregatedMetrics` is a class that aggregates data about code reviews which will be important to determine usage-based costs.

### Existing Logic:
- Payment processing and subscription management spin around Stripe, hooked up via `billing/stripe_api.py`.
- User trials get sprinkled in through `UserModel` using fields like `trial_start_date` and `is_paid_user`.

## Proposed Technical Design

Let's roll up our sleeves and map out the architecture for our credits-based model.

### Integrating Credits System:

#### Step 1: Model Changes
- **Extend UserModel**:
  - **File**: `user/models.py`
    ```python
    class UserModel(models.Model):
        ...
        credits_balance = models.IntegerField(default=0)
        credits_expiry_date = models.DateTimeField(null=True, blank=True)
    ```

#### Step 2: Consumption Logic
- **File**: `core/engine.py`
  - Introduce hooks to deduct credits each time an action (code review, doc generation) is performed:
  ```python
  def execute_code_review(user, code_complexity):
      credits_required = calculate_credits(code_complexity)
      if user.credits_balance >= credits_required:
          user.credits_balance -= credits_required
          user.save()
          return perform_code_review()
      else:
          raise InsufficientCreditsError("Not enough credits!")
  ```

#### Step 3: Usage Tracking
- Implement a metrics listener in **metrics/models.py**:
  ```python
  class CreditUsage(models.Model):
      user_uuid = models.CharField(max_length=36)
      credits_used = models.IntegerField()
      timestamp = models.DateTimeField(auto_now_add=True)
  ```

#### Step 4: UI Enhancements
- **File**: `frontend/components/CreditBalanceWidget.vue`
  - Display the current credits balance and alerts for low credits:
  ```javascript
  <template>
    <div>
      <span>Your current balance: {{creditsBalance}} credits</span>
      <span v-if="creditsBalance < 10" class="alert">Low credit warning!</span>
    </div>
  </template>

  <script>
  export default {
    data() {
      return {
        creditsBalance: 0 // Fetch this dynamically from API
      }
    }
  }
  </script>
  ```

## Implementation Tickets

### Ticket 1: Extend User Model
- **File**: `user/models.py`
- **Task**: Add fields `credits_balance` and `credits_expiry_date`.
- **Details**: Ensure that migrations are created to update the database schema.

### Ticket 2: Develop Consumption Logic
- **File**: `core/engine.py`
- **Task**: Introduce hooks to deduct credits for code review operations.
- **Details**: Add exception handling for insufficient credits.

### Ticket 3: Implement Usage Tracking
- **File**: `metrics/models.py`
- **Task**: Create a `CreditUsage` model to log all transactions.
- **Details**: Ensure entries are made during all credit-consuming actions.
  
### Ticket 4: Frontend Changes for Credits Display
- **File**: `frontend/components/CreditBalanceWidget.vue`
- **Task**: Create a Vue component to display and update user's credit information.
- **Details**: Integrate with backend API to fetch real-time credit data.

## Migration & Deployment

### Migration
1. Generate migrations for new fields in `UserModel`.
2. Run database migrations to apply changes.
3. Verify the integrity of credit balances post-migration.

### Deployment Steps
1. Deploy backend changes to staging.
2. Deploy frontend updates.
3. Conduct end-to-end testing with focus on billing and credit functionality.
4. Roll out to production following QA greenlight.

## Edge Cases & Risks

### Edge Cases:
1. **Negative Credit Operations**: Ensure transactions with negative credits are declined.
2. **Race Conditions on Credits**: Implement locking or transactional integrity in DB operations when deducting credits.

### Risks:
1. **Credit Expiry Bug**: Ensure expiry logic is robust with unit tests.
   - **Solution**: Double-check date/time handling and test across time zones.

We now have a clear path to implement this credit-based system. The next step is breaking it down ticket by ticket, so they're trackable and can iterate efficiently through our development and deployment cycles.

Feel free to jump into any part and hack away at it, or reach out if something looks off the rails. Let's make it happen! ðŸš€