# Deep Research Analysis (Updated)
*Generated by Open Deep Research*

**Repository:** https://github.com/Entelligence-AI/backend
**Original Query:** Design a usage-based pricing model for our code review and doc generation platform.
**Clarification #1:** more details on the current state
**Generated:** 2025-07-24 01:31:57
**Model:** gpt-4.1-mini

---

---
# Usage-Based Pricing & Billing Features: Current State and Enhancement Design Document  
**Date:** Thu Jul 24, 2025  
**Author:** [Your Name]  
**Audience:** Backend Development Team & Product Engineering  

---

## 1. Executive Summary

Hey team, we’ve got a billing system integrated tightly with Stripe that handles subscription lifecycle mostly based on seat counts from the users in an organization. Right now, the system knows how many seats an org has, leverages Stripe customers/subscriptions to handle plans, and exposes endpoints for checkout and subscription management.

But here’s the catch: **we do not yet have real usage event metering or granular billing features inside the app** — all metering is basically “seat count” driven, and our usage/metrics subsystem runs independently for engineering data insights, not for billing triggers.

This leaves us limited in supporting advanced usage-based pricing scenarios, like dynamic quotas, credits, free tiers, or overage handling. Our plan and subscription models are mostly on Stripe’s side, and our own data models (`StripeCustomer`, `PaymentEvent`) track linkage and status.

This design doc lays out the current landscape with intimate details on code, files, and flow — then drills down into how we can build from here a true usage-metering foundation and richer billing features that plug into our existing architecture with minimal disruptions.

---

## 2. Current State Deep Dive: What’s Under the Hood Now

### 2.1 Usage Metering & `UsageEvent`

- **No explicit `UsageEvent` model anywhere** (e.g., no `billing/models.py` or `metrics/models.py` contain usage event tables for billing).  
- Usage data currently resides in `metrics/models.py` (AggregatedMetrics, PR reviews, badges, scores), but purely for engineering insight and **not linked to billing or quotas**.  
- Metrics collection happens in `metrics/controller.py`, focusing on pull/merge request event processing, scoring, and team leaderboards. This is **functionally isolated** from billing.  

### 2.2 Billing Models & Logic

- Primary billing models live in `billing/models.py`:  
  - `StripeCustomer` — links organization UUID (`orguuid`) to a Stripe customer ID (`stripe_customer_id`).  
  - `PaymentEvent` — records Stripe subscription/payment status with fields like `stripe_subscription_id`, `status` (active, canceled, etc.), `amount`, `currency`, plus timestamps. This is our local mirror of subscription events.  
- **No internal `Plan` or `UserSubscription` models explicitly defined.** Plan and pricing info is pulled directly from Stripe’s products and prices in the controller layer.  
- User seat count comes from counting Users associated with an org — via method `get_num_of_seats(orguuid)` in `billing/repository.py` that queries `UserModel` (`user/models.py`) filtered by `organizationUUID`.  
- Subscription lifecycle is managed through Stripe interaction—creation, updates, cancellations—mostly in these files/functions:  
  - `billing/controller.py` — `get_plan_details_ctrl()`, `get_checkout_url_ctrl()`, `cancel_subscription_ctrl()`, `validate_stripe_connection()`  
  - `billing/views.py` exposes API endpoints `/get_plan_details`, `/get_checkout_url`, `/cancel_subscription`, and `/consume_stripe_webhook`.  
  - `billing/handler.py` mostly passes calls 1:1 from views to controller.

### 2.3 Pricing & Subscription Business Rules

- Pricing logic is **delegated to Stripe**; locally we:  
  - Map org to Stripe Customer and Subscription.  
  - Use seat count * Stripe price unit for cost calculations.  
  - Track subscription status (active, canceled, inactive) via local `PaymentEvent`s linked to Stripe events.  
- No internal business logic for:  
  - Quotas or seat tier limits, feature gating per plan, or dynamic plan definitions.  
  - Credits, free tiers, promo codes, or overage handling/capping.  
  - Subscription-based feature flags or restrictions.  
- Canceling subscription is done by calling Stripe API (`billing/controller.py` `cancel_subscription_ctrl`) and updating local events accordingly.

### 2.4 API Surface and Admin UI

- API lives under `billing/views.py`:  
  - `/get_plan_details` — seat counts, subscription and pricing info derived from Stripe.  
  - `/get_checkout_url` — issues Stripe checkout session link with proper validation.  
  - `/cancel_subscription` — Stripe subscription cancel API call.  
  - `/consume_stripe_webhook` — listens and processes Stripe webhook events to update local state.  
- No dedicated **admin UI** or Django Admin models visible for managing plans, usage, or subscriptions inside the app.  
- Integration points:  
  - Stripe API usage in `billing/controller.py` and webhook handling in `billing/views.py`.  
  - No internal invoice generation — relying fully on Stripe’s billing portal.  
  - No event notifications beyond Stripe webhook processing.

### 2.5 Architecture, Patterns & Identified Bottlenecks

- MVC layered pattern:  
  - `billing/models.py` (models)  
  - `billing/repository.py` (data access)  
  - `billing/controller.py` (business logic)  
  - `billing/handler.py` (handlers as thin pass-through)  
  - `billing/views.py` (API endpoints).  
- Usage and metrics (`metrics/*`) is **completely decoupled** from billing system, no shared usage event stream or billing-triggered metrics.  
- Heavy Stripe dependency: plans and subscription states are **black boxes** outside Stripe.  
- No internal plan management or quota enforcement limits extensibility.  
- No built-in metering or usage aggregation *within* billing system limits support for complex usage-based pricing.  
- Logging is detailed with Logtail integration, but no alerting or anomaly detection related to usage or billing.  
- Security risks due to plaintext secrets in `root/settings.py` and `.env`. Deployment infra (`infra/cloudformation-template.yaml`) uses AWS Secrets Manager only for DB credentials — no secret rotation or vault for Stripe keys.  
- No PCI compliance workflows or data encryption beyond relying on Stripe.

### 2.6 Summary of Key Gaps

| Feature/Capability      | Present?                  | Notes                                   |
|------------------------|--------------------------|-----------------------------------------|
| Explicit `UsageEvent` model/logging | ❌ | No usage event table for billing.   |
| Usage metering tied to billing        | ❌ | Metrics exist but not linked to billing.  |
| Internal Plan & Subscription models   | ❌ | Relies solely on Stripe for this.  |
| Quotas, free tiers, credits, overage detection | ❌ | Not implemented inside app.        |
| Admin UI for billing management       | ❌ | Absent or minimal.                  |
| Billing API endpoints                  | ✅ | Few endpoints focusing on Stripe.  |
| Stripe integration with error handling| ✅ | Good Stripe API error management.  |
| Logging and monitoring                 | ✅ | Logtail and console logging enabled.|
| Secret management                      | ❌ | Secrets in plaintext except DB password set in CloudFormation via Secrets Manager.|
| PCI compliance or audit trails         | ❌ | None detected.                     |

---

## 3. Proposed Technical Design: Building the Usage-Based Billing Foundation

To move from basic seat-based billing via Stripe to a flexible usage-based pricing system, we need to introduce **comprehensive usage event logging, internal metering, plan and subscription models with flexible rules**, while retaining existing Stripe integration as the backbone for payment and subscription state.

### 3.1 New Data Models (in `billing/models.py`)

- **`UsageEvent`**  
  Capture granular usage data linked to users/orgs and types of billable actions. Fields:  
  ```python
  class UsageEvent(models.Model):
      id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
      organization = models.ForeignKey(OrganizationModel, on_delete=models.CASCADE)
      user = models.ForeignKey(UserModel, on_delete=models.SET_NULL, null=True, blank=True)
      event_type = models.CharField(max_length=100)  # e.g., "api_call", "feature_use"
      quantity = models.FloatField(default=1.0)
      timestamp = models.DateTimeField(auto_now_add=True)
      metadata = JSONField(blank=True, null=True)  # extra data like usage context
  ```
- **`Plan` & `UserSubscription`** (mirror but extend Stripe plans)  
  Internal representations to store business rules, pricing tiers, quotas, feature flags per plan:  
  ```python
  class Plan(models.Model):
      stripe_price_id = models.CharField(max_length=100, unique=True)
      name = models.CharField(max_length=100)
      description = models.TextField(blank=True)
      features = JSONField(default=dict)  # e.g. {"max_api_calls": 10000, "free_tier": True}
      base_price_cents = models.IntegerField()
      billing_interval = models.CharField(max_length=10, choices=[("month", "Month"), ("year", "Year")])
  
  class UserSubscription(models.Model):
      user = models.ForeignKey(UserModel, on_delete=models.CASCADE, null=True, blank=True)
      organization = models.ForeignKey(OrganizationModel, on_delete=models.CASCADE)
      plan = models.ForeignKey(Plan, on_delete=models.CASCADE)
      start_date = models.DateTimeField()
      end_date = models.DateTimeField(null=True, blank=True)
      status = models.CharField(max_length=20, choices=[('active','Active'), ('canceled','Canceled')])
      seats = models.IntegerField(default=1)
      quantity = models.IntegerField(default=0) # e.g., for metered components
      credits = models.FloatField(default=0)  # track credits applied to subscription
      overage_charges = models.FloatField(default=0)
  ```

### 3.2 Usage Logging Flow (Extend across core apps)

- Instrument points of revenue-impacting usage in the codebase (e.g., API entry points in `api/views.py`, feature modules) to log a `UsageEvent`.  
- UsageEvent logging to be asynchronous (via a task queue like Celery or background process) to prevent API latency spikes.  
- Ingest UsageEvents periodically into aggregated tables (`billing_usage_aggregation`) for quota enforcement and billing calculation.

### 3.3 Pricing and Quotas Implementation

- Add internal logic (in `billing/controller.py`) to:  
  - Enforce quotas against defined plan features (e.g., max API calls allowed).  
  - Calculate overages by comparing actual usage against plan limits and free tiers.  
  - Apply credits/discounts stored in `UserSubscription`.  
- Provide query methods in `billing/repository.py` for usage aggregation and quota checks, e.g.,  
  `get_usage_summary(org_uuid, start_date, end_date)` returns aggregated usage per event_type.

### 3.4 Billing API Extensions

- Extend `billing/views.py` to expose endpoints:  
  - `GET /billing/usage_summary` — returns usage metrics for an org or user bound by plan limits.  
  - `POST /billing/apply_credit` — apply discounts or credits to subscription.  
  - `POST /billing/report_overage` — API to trigger recalculation or manual reporting of overages and bill adjustments if needed.  
- Enhance `/get_plan_details` to include internal plan features and quota states along with Stripe pricing data.

### 3.5 Admin UI Additions (Django Admin or React-based dashboard)

- Add `Plan` and `UserSubscription` management interfaces.  
- Show usage summaries, quota alerts, overage reports per org/user.  
- Allow manual credit assignments and plan modifications.  

### 3.6 Stripe Integration Adjustments

- While continuing to rely on Stripe for payment collection and subscription lifecycle, shift metering and quota enforcement *into the app*:  
  - Report usage-based metering metrics to Stripe when applicable (Stripe Usage Records API) for metered billing products if leveraging Stripe metered billing.  
  - Or handle metered billing calculations internally and use Stripe to bill a calculated invoice amount if metered billing via Stripe is not sufficient.  
- Update webhook handling in `/consume_stripe_webhook` to sync internal subscription statuses and reconcile usage/charges.

### 3.7 Logging, Monitoring, & Compliance

- Enhance logging to include logging of usage event ingestion and quota enforcement decisions (`billing/views.py` and `billing/controller.py`).  
- Add error alerts and anomaly detection hooks (potentially integrating with Slack or PagerDuty) on billing anomalies or failed payments.  
- Secure billing secrets by moving Stripe API keys into a secrets manager or vault (extend AWS Secrets Manager usage currently done only for DB).  
- Remove plaintext secrets from code and `.env`.  
- Add periodic audits and logging retention policies aligned to PCI DSS recommendations (logs at least 1 year retention, encryption at rest).  
- Consider GDPR impact on storing usage data (anonymize or aggregate as needed).

---

## 4. Implementation Tickets (Ticket-Ready Chunks)

### Ticket #1: Add `UsageEvent` model and async logging mechanism  
- *Files:* `billing/models.py`, `billing/tasks.py` (new), relevant API views to inject usage event logging.  
- *Details:*  
  - Define `UsageEvent` model (see Sec 3.1).  
  - Implement Celery task `log_usage_event_async`.  
  - Add usage logging calls in identified revenue-impacting APIs (`api/views.py` or feature modules).  
- *Outcome:* Reliable asynchronous granular usage capture for billing.

### Ticket #2: Define internal `Plan` and `UserSubscription` models with admin UI  
- *Files:* `billing/models.py`, `billing/admin.py` (new or extend if exists).  
- *Details:* Add models per Sec 3.1, register in admin UI.  
- *Outcome:* Internal plan and subscription repository to support business logic beyond Stripe.

### Ticket #3: Implement Usage Aggregation and Quota Enforcement logic  
- *Files:* `billing/repository.py`, `billing/controller.py`  
- *Details:*  
  - Functions querying usage events aggregate data for given org and time ranges.  
  - Methods to check quotas and calculate overages per plan features and usage aggregates.  
- *Outcome:* Can calculate real usage against plan limits for billing decisions.

### Ticket #4: Extend billing APIs for usage summary and credit management  
- *Files:* `billing/views.py`, `billing/handler.py`, `billing/controller.py`  
- *Details:* New API views/endpoints for usage summary, applying credits, and fetching plan features.  
- Add request validation, error handling, and logging consistent with existing patterns.  
- *Outcome:* Expose usage and billing controls to frontends.

### Ticket #5: Update Stripe webhook handling to sync internal usage and subscriptions  
- *Files:* `billing/views.py` (webhook handler), `billing/controller.py`  
- *Details:*  
  - Update webhook parsing logic to update `UserSubscription` status.  
  - If using Stripe usage records API, reconcile usage events.  
- *Outcome:* Reliable synchronization of Stripe state to internal models.

### Ticket #6: Secrets and Security Hardening  
- *Files:* `root/settings.py`, `.env` (remove secrets), `infra/cloudformation-template.yaml`  
- *Details:*  
  - Move Stripe API keys to AWS Secrets Manager or Vault.  
  - Refactor to load secrets from secure store instead of plaintext.  
  - Restrict open ports in infra security groups (close DB port from open internet).  
  - Disable `DEBUG` in production configs.  
- *Outcome:* Improved security posture and compliance groundwork.

### Ticket #7: Monitoring and Alerting Setup for Billing  
- *Files:* Logging config files (possibly new `billing/monitoring.py`)  
- *Details:* Add log alerts and integrate webhook failures, payment failures with PagerDuty/Slack.  
- *Outcome:* Proactive monitoring of billing anomalies.

---

## 5. Code Snippets: Integration Points & Examples

### 5.1 Adding UsageEvent model snippet in `billing/models.py`
```python
from django.db import models
import uuid
from django.contrib.postgres.fields import JSONField

class UsageEvent(models.Model):
    id = models.UUIDField(primary_key=True, default=uuid.uuid4, editable=False)
    organization = models.ForeignKey('organization.OrganizationModel', on_delete=models.CASCADE)
    user = models.ForeignKey('user.UserModel', on_delete=models.SET_NULL, null=True, blank=True)
    event_type = models.CharField(max_length=100)
    quantity = models.FloatField(default=1.0)
    timestamp = models.DateTimeField(auto_now_add=True)
    metadata = JSONField(blank=True, null=True)
    
    class Meta:
        indexes = [models.Index(fields=['organization', 'timestamp'])]
```

### 5.2 Example async usage logger (`billing/tasks.py`)
```python
from celery import shared_task
from .models import UsageEvent

@shared_task
def log_usage_event_async(org_uuid, user_uuid, event_type, quantity=1.0, metadata=None):
    UsageEvent.objects.create(
        organization_id=org_uuid,
        user_id=user_uuid,
        event_type=event_type,
        quantity=quantity,
        metadata=metadata or {}
    )
```

### 5.3 Injecting usage logging in API (e.g., `api/views.py`)
```python
from billing.tasks import log_usage_event_async
from rest_framework.decorators import api_view

@api_view(['POST'])
def some_feature_use(request):
    user = request.user
    org_uuid = user.organizationUUID
    
    # Perform feature logic...
    
    # Log usage event asynchronously
    log_usage_event_async.delay(org_uuid, user.uuid, 'feature_x_usage', quantity=1)
    
    return Response({"status": "success"})
```

### 5.4 Internal plan check example in `billing/controller.py`
```python
def check_quota_and_overage(orguuid):
    subscription = UserSubscription.objects.filter(organization__orgUUID=orguuid, status="active").first()
    if not subscription:
        return None, "No active subscription found"
    
    usage_summary = get_usage_summary(orguuid)  # implement aggregation query

    quota = subscription.plan.features.get("max_api_calls", 0)
    usage = usage_summary.get("api_call", 0)
    
    if usage > quota:
        overage = usage - quota
        # Update subscription.overage_charges accordingly...
        # Trigger alerts or invoice overage fees
    
    return usage, quota
```

---

## 6. Migration & Deployment Notes

- **DB migrations**  
  - Add migrations for new `UsageEvent`, `Plan`, `UserSubscription` models.  
  - Potentially backfill existing usage data from metrics app if feasible.  
- **Secrets rotation**  
  - Coordinate deployment to securely move Stripe keys to Secrets Manager, update app to read from there.  
- **Incremental rollout**  
  - Start by adding usage event logging but keep current billing flows intact.  
  - Phase in quota enforcement after sufficient usage data accumulates.  
  - Update API clients and frontend interfaces in parallel with backend API enhancement tickets.  
- **Infrastructure security update**  
  - Harden VPC security groups per infra/cloudformation-template.yaml audit.  
  - Implement automated config scans to prevent accidental exposure of ports.  
- **CI/CD**  
  - Extend GitHub workflows to include environment configuration checks with updated Secrets Manager usage.

---

## 7. Edge Cases & Risks

| Risk/Edge Case                                | Mitigation & Notes                             |
|-----------------------------------------------|-----------------------------------------------|
| High usage event volume causing DB bloat     | Use async logging and batch aggregation; archive old usage events monthly. |
| Discrepancies between Stripe and internal state | Reconcile subscriptions regularly using webhook and scheduled jobs. |
| Lack of data consistency between `UserSubscription` and Stripe | Implement idempotent webhook handlers, audit logs for manual fixes. |
| Overages without customer notification        | Build notification system (email, webhooks) when quotas are exceeded. |
| Secrets leakage due to plaintext vars         | Migrate to Secrets Manager and rotate keys frequently. |
| Unhandled Stripe errors causing billing failures | Maintain robust error handling and retries in `billing/controller.py`. |
| Migration of existing customers to new plans  | Build migration scripts mapping Stripe products/prices to internal Plans carefully. |
| Usage event schema evolution and backward compatibility | Version usage event payloads and implement converter layers if needed. |

---

# Summary

We're standing on solid ground with Stripe handling seat-based billing, but to deliver flexible usage-based pricing, **we need to build an internal metering foundation**. That includes a new `UsageEvent` model, plan/subscription abstraction, quota enforcement, and a richer API, all while improving security and compliance aspects.

The architecture is modular enough to extend without massive rewiring — the biggest lift is implementing event logging, aggregation, and syncing that with billing logic.

This doc breaks down the work into manageable, well-contained tickets. Let's iterate fast, add usage metering next to our existing Stripe billing, and layer advanced billing logic atop our solid API and subscription foundation.

---

If you want, I can help draft specific ticket descriptions and acceptance criteria for sprint backlog. Just shout!